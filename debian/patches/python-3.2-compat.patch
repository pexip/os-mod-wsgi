Description: Patch to allow Python 3.2 to be used. 
 May be incompatible with using mod_python at the same time so upstream patch
 modified locally to apply changes only when compiling against python 3.2.
Origin: http://code.google.com/p/modwsgi/source/detail?r=8633d5afeea845a12c028cfae31dc828c5ce8908
Author: Graham Dumpleton <Graham.Dumpleton@gmail.com>
Forwarded: not-needed

Index: fix-759943-2/mod_wsgi.c
===================================================================
--- fix-759943-2.orig/mod_wsgi.c	2011-04-19 18:13:25.680114438 +0100
+++ fix-759943-2/mod_wsgi.c	2011-04-19 18:33:24.816199741 +0100
@@ -386,6 +386,10 @@
 #define WSGI_RELOAD_MODULE 0
 #define WSGI_RELOAD_PROCESS 1
 
+/* Python interpreter state. */
+#if PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION >= 2
+static PyThreadState *wsgi_main_tstate = NULL;
+#endif
 /* Base server object. */
 
 static server_rec *wsgi_server = NULL;
@@ -3598,7 +3602,11 @@
      */
 
     if (!wsgi_daemon_pool && self->config->pass_apache_request) {
+#if PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION >= 2
+        object = PyCapsule_New(self->r, 0, 0);
+#else
         object = PyCObject_FromVoidPtr(self->r, 0);
+#endif
         PyDict_SetItemString(vars, "apache.request_rec", object);
         Py_DECREF(object);
     }
@@ -5147,6 +5155,24 @@
     PyObject *exitfunc = NULL;
     PyObject *module = NULL;
 
+#if PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION >= 2
+    PyThreadState *tstate_enter = NULL;
+
+    /*
+     * We should always enter here with the Python GIL
+     * held and an active thread state. This should only
+     * now occur when shutting down interpreter and not
+     * when releasing interpreter as don't support
+     * recyling of interpreters within the process. Thus
+     * the thread state should be that for the main
+     * Python interpreter. Where dealing with a named
+     * sub interpreter, we need to change the thread
+     * state to that which was originally used to create
+     * that sub interpreter before doing anything.
+     */
+
+    tstate_enter = PyThreadState_Get();
+#else
     /*
      * We should always enter here with the Python GIL held, but
      * there will be no active thread state. Note that it should
@@ -5156,6 +5182,7 @@
      */
 
     PyEval_ReleaseLock();
+#endif
 
     if (*self->name) {
 #if APR_HAS_THREADS
@@ -5194,10 +5221,20 @@
         tstate = self->tstate;
 #endif
 
+#if PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION >= 2
+        /*
+	 * Swap to interpreter thread state that was used when
+	 * the sub interpreter was created.
+         */
+
+        PyThreadState_Swap(tstate);
+    }
+#else
         PyEval_AcquireThread(tstate);
     }
     else
         PyGILState_Ensure();
+#endif
 
     if (self->owner) {
         Py_BEGIN_ALLOW_THREADS
@@ -5492,6 +5529,9 @@
 
     /* If we own it, we destroy it. */
 
+#if PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION >= 2
+    if (self->owner) {
+#else
     if (!self->owner) {
         if (*self->name) {
             tstate = PyThreadState_Get();
@@ -5506,6 +5546,7 @@
         PyEval_AcquireLock();
     }
     else {
+#endif
         /*
          * We need to destroy all the thread state objects
          * associated with the interpreter. If there are
@@ -5539,6 +5580,10 @@
         /* Can now destroy the interpreter. */
 
         Py_EndInterpreter(tstate);
+
+#if PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION >= 2
+        PyThreadState_Swap(tstate_enter);
+#endif
     }
 
     free(self->name);
@@ -5647,7 +5692,18 @@
     ap_log_error(APLOG_MARK, WSGI_LOG_INFO(0), wsgi_server,
                  "mod_wsgi (pid=%d): Terminating Python.", getpid());
 
+#if PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION >= 2
+    /*
+     * We should be executing in the main thread again at this
+     * point but without the GIL, so simply restore the original
+     * thread state for that thread that we remembered when we
+     * initialised the interpreter.
+     */
+
+    PyEval_AcquireThread(wsgi_main_tstate);
+#else
     PyGILState_Ensure();
+#endif
 
     /*
      * Work around bug in Python 3.X whereby it will crash if
@@ -5822,15 +5878,28 @@
         /* Initialise threading. */
 
         PyEval_InitThreads();
+#if PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION >= 2
+        /*
+	 * We now want to release the GIL. Before we do that
+	 * though we remember what the current thread state is.
+	 * We will use that later to restore the main thread
+	 * state when we want to cleanup interpreters on
+	 * shutdown.
+         */
+
+        wsgi_main_tstate = PyThreadState_Get();
+        PyEval_ReleaseThread(wsgi_main_tstate);
+#else
         PyThreadState_Swap(NULL);
         PyEval_ReleaseLock();
+#endif
 
         wsgi_python_initialized = 1;
 
-    /*
-     * Register cleanups to be performed on parent restart
-     * or shutdown. This will destroy Python itself.
-     */
+        /*
+         * Register cleanups to be performed on parent restart
+         * or shutdown. This will destroy Python itself.
+         */
 
 #if AP_SERVER_MAJORVERSION_NUMBER < 2
         ap_register_cleanup(p, NULL, wsgi_python_parent_cleanup,
@@ -5879,7 +5948,11 @@
 
     /*
      * This function should never be called when the
-     * Python GIL is held, so need to acquire it.
+     * Python GIL is held, so need to acquire it. Even
+     * though we may need to work with a sub
+     * interpreter, we need to acquire GIL against main
+     * interpreter first to work with interpreter
+     * dictionary.
      */
 
     state = PyGILState_Ensure();
@@ -5998,6 +6071,10 @@
 {
     PyThreadState *tstate = NULL;
 
+#if PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION >= 2
+    PyGILState_STATE state;
+#endif
+
     /*
      * Need to release and destroy the thread state that
      * was created against the interpreter. This will
@@ -6023,11 +6100,19 @@
      * in its destruction if its the last reference.
      */
 
+#if PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION >= 2
+    state = PyGILState_Ensure();
+#else
     PyEval_AcquireLock();
+#endif
 
     Py_DECREF(handle);
 
+#if PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION >= 2
+    PyGILState_Release(state);
+#else
     PyEval_ReleaseLock();
+#endif
 }
 
 /*
@@ -6630,8 +6715,18 @@
     apr_thread_mutex_lock(wsgi_interp_lock);
 #endif
 
-    PyEval_AcquireLock();
+#if PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION >= 2
+    /*
+     * We should be executing in the main thread again at this
+     * point but without the GIL, so simply restore the original
+     * thread state for that thread that we remembered when we
+     * initialised the interpreter.
+     */
 
+    PyEval_AcquireThread(wsgi_main_tstate);
+#else
+    PyEval_AcquireLock();
+#endif
     /*
      * Extract a handle to the main Python interpreter from
      * interpreters dictionary as want to process that one last.
@@ -6668,7 +6763,17 @@
 
     Py_DECREF(interp);
 
+#if PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION >= 2
+    /*
+     * The code which performs actual shutdown of the main
+     * interpreter expects to be called without the GIL, so
+     * we release it here again.
+     */
+
+    PyEval_ReleaseThread(wsgi_main_tstate);
+#else
     PyEval_ReleaseLock();
+#endif
 
     /*
      * Destroy Python itself including the main interpreter.
@@ -8369,7 +8474,11 @@
      */
 
     if (!wsgi_daemon_pool && self->config->pass_apache_request) {
+#if PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION >= 2
+        object = PyCapsule_New(self->r, 0, 0);
+#else
         object = PyCObject_FromVoidPtr(self->r, 0);
+#endif
         PyDict_SetItemString(vars, "apache.request_rec", object);
         Py_DECREF(object);
     }
@@ -10509,6 +10618,10 @@
 {
     WSGIDaemonProcess *daemon = data;
 
+#if PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION >= 2
+    PyGILState_STATE gilstate;
+#endif
+
     if (wsgi_server_config->verbose_debugging) {
         ap_log_error(APLOG_MARK, WSGI_LOG_DEBUG(0), wsgi_server,
                      "mod_wsgi (pid=%d): Enable deadlock thread in "
@@ -10523,8 +10636,13 @@
     while (1) {
         apr_sleep(apr_time_from_sec(1));
 
+#if PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION >= 2
+        gilstate = PyGILState_Ensure();
+        PyGILState_Release(gilstate);
+#else
         PyEval_AcquireLock();
         PyEval_ReleaseLock();
+#endif
 
         apr_thread_mutex_lock(wsgi_shutdown_lock);
         wsgi_deadlock_shutdown_time = apr_time_now();
@@ -11101,6 +11219,7 @@
         if (wsgi_python_after_fork)
             wsgi_python_init(p);
 
+#if PY_MAJOR_VERSION < 3
         /*
          * If mod_python is also being loaded and thus it was
          * responsible for initialising Python it can leave in
@@ -11110,7 +11229,9 @@
          * initialisation but in daemon process we skip the
          * mod_python child initialisation so the active thread
          * state still exists. Thus need to do a bit of a fiddle
-         * to ensure there is no active thread state.
+         * to ensure there is no active thread state. Don't need
+         * to worry about this with Python 3.X as mod_python
+         * only supports Python 2.X.
          */
 
         if (!wsgi_python_initialized) {
@@ -11126,6 +11247,7 @@
 
             PyEval_ReleaseLock();
         }
+#endif
 
         /*
          * If the daemon is associated with a virtual host then
@@ -13372,7 +13494,11 @@
      */
 
     if (!wsgi_daemon_pool && self->config->pass_apache_request) {
+#if PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION >= 2
+        object = PyCapsule_New(self->r, 0, 0);
+#else
         object = PyCObject_FromVoidPtr(self->r, 0);
+#endif
         PyDict_SetItemString(vars, "apache.request_rec", object);
         Py_DECREF(object);
     }
